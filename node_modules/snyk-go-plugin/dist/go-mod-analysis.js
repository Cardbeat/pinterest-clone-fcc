"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const snyk_go_parser_1 = require("snyk-go-parser");
const subProcess = require("./sub-process");
const gomod_parser_1 = require("snyk-go-parser/dist/gomod-parser");
function moduleAtVersionToSnykVersion(mv) {
    const parts = mv.split('@');
    if (parts.length > 2) {
        throw new Error('Invalid module@version: ' + mv);
    }
    if (parts.length === 2) {
        return `${parts[0]}@${snyk_go_parser_1.toSnykVersion(gomod_parser_1.parseVersion(parts[1]))}`;
    }
    return parts[0];
}
// Runs `go mod graph` in the target folder and builds a graph of module relationships
// with versions.
function buildModuleGraph(root) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const graph = {
            root: '',
            edges: {},
        };
        const graphStr = yield subProcess.execute('go', ['mod', 'graph'], { cwd: root });
        const lines = graphStr.trim().split('\n');
        if (lines) {
            graph.root = lines[0].split(' ')[0];
            // First pass: record versions in Go Modules format
            for (const line of lines) {
                const [from, to] = line.trim().split(' ').map(moduleAtVersionToSnykVersion);
                if (!graph.edges[from]) {
                    graph.edges[from] = [];
                }
                graph.edges[from].push(to);
            }
        }
        return graph;
    });
}
exports.buildModuleGraph = buildModuleGraph;
function isPackageInTheModule(packageName, moduleName) {
    const reModuleName = /^(.+?)(\/v[0-9]+)?$/;
    const unversionedModuleName = reModuleName.exec(moduleName)[1];
    return packageName.startsWith(unversionedModuleName);
}
exports.isPackageInTheModule = isPackageInTheModule;
//# sourceMappingURL=go-mod-analysis.js.map